{"./":{"url":"./","title":"Git","keywords":"","body":"Git Git 是一个分布式版本控制系统。 "},"docs/安装 Git.html":{"url":"docs/安装 Git.html","title":"安装 Git","keywords":"","body":"安装 Git 如果你想在 Linux 上用二进制安装程序来安装 Git ，可以使用发行版包含的基础软件包管理工具来安装。以 Fedora 为例，可以执行下面的命令来安装。 sudo yum install git 如果你在基于 Debian 的发行版上，可以执行下面的命令来安装。 sudo apt-get install git 要了解更多选择， Git 官方网站上有在各种 Unix 风格系统上的 安装步骤 。在 Mac 上安装 Git 有多种方式，最简单的方法是安装 Xcode Command Line Tools ，如果你想安装更新的版本，可以使用二进制安装程序。官方维护的 OSX Git 安装程序可以在 Git 官方网站 下载 。在 Windows 上安装 Git 也有几种安装方法，官方版本可以在 Git 官方网站 下载 。另一个简单的方法是安装 GitHub Desktop ，该安装程序包含图形化和命令行版本的 Git 。 "},"docs/初始化.html":{"url":"docs/初始化.html","title":"初始化","keywords":"","body":"初始化 当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。这样做很重要，因为每一次 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改。如果使用了 --global 选项，那么下面命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 --global 选项的命令来配置。 git config --global user.name \"kuriv\" git config --global user.email \"kuri.personal@gmail.com\" 如果想要检查你的配置，可以执行下面的命令来列出当前的 Git 配置。 git config --list 也可以执行下面的命令来检查 Git 的某一项配置。 git config user.name "},"docs/创建仓库.html":{"url":"docs/创建仓库.html","title":"创建仓库","keywords":"","body":"创建仓库 有两种创建 Git 项目仓库的方法。第一种是在现有项目或目录下导入所有文件到 Git 中。第二种是从一个服务器克隆一个现有的 Git 仓库。如果你打算使用 Git 来对现有的项目进行管理，你只需要进入该项目目录并执行下面的命令。该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件。 git init 如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到下面的命令。这会在当前目录下创建一个对应的目录，并在这个目录下初始化一个 .git 子目录，从远程仓库拉取下所有数据放入 .git 子目录，然后从中读取最新版本的文件的拷贝。 git clone https://github.com/kuriv/manual-git.git "},"docs/查看状态.html":{"url":"docs/查看状态.html","title":"查看状态","keywords":"","body":"查看状态 工作区下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。工作区中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。初次克隆某个仓库的时候，工作区中的所有文件都属于已跟踪文件，并处于未修改状态。编辑过某些文件之后，由于自上次提交后你对它们做了修改， Git 将它们标记为已修改文件。逐步将这些修改过的文件放入暂存区，然后提交所有暂存的修改，如此反复。 要查看哪些文件处于什么状态，可以执行下面的命令。 git status 如果在克隆仓库后立即执行此命令，会看到类似这样的输出。 On branch master nothing to commit, working tree clean 这说明现在的工作区相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。最后，该命令还显示了当前所在分支。 "},"docs/忽略文件.html":{"url":"docs/忽略文件.html","title":"忽略文件","keywords":"","body":"忽略文件 总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是一些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。在这种情况下，你可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。 *.log *~ 要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这些无用的文件。 "},"docs/记录更新.html":{"url":"docs/记录更新.html","title":"记录更新","keywords":"","body":"记录更新 在项目下创建一个新的 README.md 文件，查看文件状态，可以看到新的 README.md 文件出现在 Untracked files 下面。未跟踪的文件意味着 Git 在之前的提交中没有这些文件。 Git 不会自动将其纳入跟踪范围，除非你指定需要跟踪该文件，这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。 On branch master No commits yet Untracked files: (use \"git add ...\" to include in what will be committed) README.md nothing added to commit but untracked files present (use \"git add\" to track) 执行下面的命令开始跟踪 README.md 文件。 git add README.md 此时查看文件状态，会看到 README.md 文件出现在 Changes to be committed 下面，说明已处于暂存状态。如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。 On branch master No commits yet Changes to be committed: (use \"git rm --cached ...\" to unstage) new file: README.md 修改 README.md 文件的内容后，再次查看文件状态，会看到 README.md 文件出现在 Changes not staged for commit 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。要暂存这次更新，执行和上面一样的命令即可。这是个多功能命令，可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。将这个命令理解为添加内容到下一次提交中而不是将一个文件添加到项目中要更加合适。 On branch master No commits yet Changes to be committed: (use \"git rm --cached ...\" to unstage) new file: README.md Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: README.md "},"docs/删除文件.html":{"url":"docs/删除文件.html","title":"删除文件","keywords":"","body":"删除文件 要从 Git 中删除某个文件，就必须要从已跟踪文件清单中删除，确切地说，是从暂存区域删除，然后提交。可以执行下面的命令删除 README.md 文件，并连带从工作区中删除它。下一次提交时，该文件就不再纳入版本管理了。 git rm README.md "},"docs/重命名文件.html":{"url":"docs/重命名文件.html","title":"重命名文件","keywords":"","body":"重命名文件 不像其它的版本控制系统， Git 并不显式跟踪文件移动操作。如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次重命名操作。可以执行下面的命令将 README.md 文件重命名。 git mv README.md README "},"docs/查看修改.html":{"url":"docs/查看修改.html","title":"查看修改","keywords":"","body":"查看修改 如果想查看具体修改的位置，可以执行下面的命令。这个命令比较的是工作区中当前文件和暂存区快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。 git diff 若要查看已暂存的将要添加到下次提交里的内容，可以执行下面的命令。 git diff --cached "},"docs/提交更新.html":{"url":"docs/提交更新.html","title":"提交更新","keywords":"","body":"提交更新 现在的暂存区已经准备妥当可以提交了。在此之前，请一定要确认还有什么修改过的或新建的文件还没有被添加到暂存区，否则提交的时候不会记录这些还没暂存起来的变化。这些修改过的文件只保留在本地磁盘。所以，每次准备提交前，先查看文件状态，是不是都已暂存起来了， 然后再执行下面的命令，启动文本编辑器以便输入本次提交的说明。 git commit 另外，也可以执行下面的命令将提交信息与命令放在同一行。 git commit -m \"COMMENT\" 执行成功后可以看到当前是在哪个分支提交的，本次提交的完整 SHA-1 校验和是什么，以及在本次提交中有多少文件修订过，多少行添加和删改过。 "},"docs/提交历史.html":{"url":"docs/提交历史.html","title":"提交历史","keywords":"","body":"提交历史 在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。完成这个任务最简单而又有效是执行下面的命令。默认不用任何参数的话，该命令会按提交时间列出所有的更新，最近的更新排在最上面。同时列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。 git log 另外一个常用的选项是 --pretty 。这个选项可以指定使用不同于默认格式的方式展示提交历史。 git log --pretty=oneline "},"docs/撤销操作.html":{"url":"docs/撤销操作.html","title":"撤销操作","keywords":"","body":"撤销操作 在任何一个阶段，你都有可能想要撤消某些操作。注意，有些撤消操作是不可逆的。这是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。有时候你提交完了才发现提交信息写错了，或者漏掉了几个文件。 此时，可以执行下面的命令。这个命令会将暂存区中的文件提交。如果自上次提交以来你还未做任何修改，例如，在上次提交后马上执行了此命令，那么快照会保持不变，而你所修改的只是提交信息。文本编辑器启动后，可以看到之前的提交信息。编辑后保存会覆盖原来的提交信息。 git commit --amend 例如，你提交后发现忘记了暂存了 FORGOTTEN.md 的修改，可以执行下面的命令。最终你只会有一个提交，第二次提交将代替第一次提交的结果。 git add FORGOTTEN.md git commit --amend 例如，你已经修改了两个文件 FILE1.md 和 FILE2.md 并且想要将它们作为两次独立的修改提交，但是却意外地暂存了它们两个。可以执行下面的命令取消暂存其中的一个文件 FILE2.md 。 git reset HEAD FILE2.md 例如，你已经修改了 README.md 文件，但是又突然不想保留对 README.md 文件的修改了。可以执行下面的命令方便地撤消修改，将它还原成上次提交时的样子。 git checkout -- README.md 在 Git 中任何已提交的东西几乎总是可以恢复的。然而，任何你未提交的东西丢失后很可能再也找不到了。 "},"docs/查看分支.html":{"url":"docs/查看分支.html","title":"查看分支","keywords":"","body":"查看分支 执行下面的命令，可以查看当前所有分支的列表。分支名前的星号代表现在检出的那一个分支（也就是说，当前 HEAD 指针所指向的分支）。这意味着如果在这时候提交，当前检出的分支将会随着新的工作向前移动。 git branch 如果需要查看每一个分支的最后一次提交，可以执行下面的命令。 git branch -v "},"docs/创建分支.html":{"url":"docs/创建分支.html","title":"创建分支","keywords":"","body":"创建分支 如果你想要新建一个 develop 分支并同时切换到那个分支上，可以执行下面的命令。 git checkout -b develop 上面的命令是下面两条命令的简写。 git branch develop git checkout develop "},"docs/合并分支.html":{"url":"docs/合并分支.html","title":"合并分支","keywords":"","body":"合并分支 如果你在 develop 分支上提交了修改，并且打算将修改合并入 master 分支。你只需要检出到 master 分支，然后执行下面的命令。 git merge develop 有时候合并操作不会如此顺利。如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改， Git 就没法干净的合并它们。此时 Git 虽然做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。你可以在合并冲突后的任意时刻使用查看文件状态命令来查看那些因包含合并冲突而处于未合并状态的文件。任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。在你解决了所有文件里的冲突之后，把每个文件放到暂存区来将其标记为冲突已解决。一旦暂存这些原本有冲突的文件， Git 就会将它们标记为冲突已解决。如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以提交更新来完成合并提交。 "},"docs/删除分支.html":{"url":"docs/删除分支.html","title":"删除分支","keywords":"","body":"删除分支 如果你已经不再需要某个分支了，可以在任务追踪系统中关闭此项任务，并删除这个分支。可以执行下面的命令删除 develop 分支。 git branch -d develop "},"docs/生成 SSH 公钥.html":{"url":"docs/生成 SSH 公钥.html","title":"生成 SSH 公钥","keywords":"","body":"生成 SSH 公钥 现在，你完全可以使用 HTTPS 协议，通过 GitHub 账号访问 Git 版本库。但是，如果仅仅克隆公有项目，你甚至不需要使用 GitHub 账号。如果你习惯使用 SSH 远程，你需要配置一个公钥。许多 Git 服务器都使用 SSH 公钥进行认证。为了向 Git 服务器提供 SSH 公钥，如果某系统用户尚未拥有密钥，必须事先为其生成一份。首先，你需要确认自己是否已经拥有密钥。默认情况下，用户的 SSH 密钥存储在其 ~/.ssh 目录下。进入该目录并列出其中内容，你便可以快速确认自己是否已拥有密钥。你需要寻找一对以 id_dsa 或 id_rsa 命名的文件，其中一个带有 .pub 扩展名的文件是你的公钥，另一个则是私钥。 cd ~/.ssh ls 如果找不到这样的文件，或者根本没有 .ssh 目录，你可以通过执行下面的命令来创建它们。该命令会确认密钥的存储位置（默认 .ssh/id_rsa ），然后它会要求你输入两次密钥口令。如果你不想在使用密钥时输入口令，将其留空即可。 ssh-keygen "},"docs/查看远程仓库.html":{"url":"docs/查看远程仓库.html","title":"查看远程仓库","keywords":"","body":"查看远程仓库 为了能在任意 Git 项目上协作，你需要知道如何管理自己的远程仓库。远程仓库是指托管在互联网或其它网络中的你的项目的版本库。你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。如果想查看你已经配置的远程仓库服务器，可以执行下面的命令。它会列出你指定的每一个远程服务器的简写。 git remote 你也可以指定选项 -v ，这样会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL 。 git remote -v 如果你已经克隆了自己的仓库，那么至少应该能看到 origin ，这是 Git 给你克隆的仓库服务器的默认名字。如果想要查看简写为 origin 的远程仓库的更多信息，可以执行下面的命令。 git remote show origin "},"docs/添加远程仓库.html":{"url":"docs/添加远程仓库.html","title":"添加远程仓库","keywords":"","body":"添加远程仓库 可以执行下面的命令添加一个新的 Git 远程仓库，同时指定一个轻松引用的 develop 简写名。 git remote add develop git@github.com:kuriv/manual-git.git "},"docs/从远程仓库拉取.html":{"url":"docs/从远程仓库拉取.html","title":"从远程仓库拉取","keywords":"","body":"从远程仓库拉取 如果想要从简写为 develop 的远程仓库中拉取数据，可以执行下面的命令。这个命令从远程仓库上拉取本地没有的数据，它并不会修改工作区中的内容。它只会获取数据然后让你自己合并。 git fetch develop 如果你有一个分支设置为跟踪一个远程分支，也可以执行下面的命令来自动的拉取然后合并远程分支到当前分支。这对你来说可能是一个更简单或更舒服的工作流程。 git pull "},"docs/推送到远程仓库.html":{"url":"docs/推送到远程仓库.html","title":"推送到远程仓库","keywords":"","body":"推送到远程仓库 当你想分享你的项目时，必须将其推送到远程仓库上。比如说，你想要将 master 分支推送到简写为 develop 远程仓库上时，那么可以执行下面的命令。 git push develop master 只有当你有远程仓库的写入权限，并且之前没有人推送过时，这条命令才能生效。当你和其他人在同一时间推送，他们先推送到远程仓库然后你再推送到远程仓库，你的推送就会毫无疑问地被拒绝。你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。 "},"docs/删除远程仓库.html":{"url":"docs/删除远程仓库.html","title":"删除远程仓库","keywords":"","body":"删除远程仓库 如果你因为一些原因想要删除一个远程仓库，比如说，你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了，可以执行下面的命令删除简写为 develop 的远程仓库。 git remote rm develop "},"docs/重命名远程仓库.html":{"url":"docs/重命名远程仓库.html","title":"重命名远程仓库","keywords":"","body":"重命名远程仓库 如果你想要重命名简写的名字可以执行下面的命令，该命令将简写为 develop 的远程仓库重命名。 git remote rename develop dev "},"docs/查看标签.html":{"url":"docs/查看标签.html","title":"查看标签","keywords":"","body":"查看标签 像其它版本控制系统一样， Git 可以给历史中的某一次提交创建标签，以示重要。在 Git 中列出已有的标签是非常简单直观的，只需要执行下面的命令。 git tag 你也可以使用特定的模式查找标签。例如，如果只对 v1.8.5 系列感兴趣，可以执行下面的命令。 git tag -l \"v1.8.5*\" 如果你想要查看 v1.8.5 的标签信息和对应的提交信息，可以执行下面的命令。 git show v1.8.5 "},"docs/创建标签.html":{"url":"docs/创建标签.html","title":"创建标签","keywords":"","body":"创建标签 轻量标签很像不会改变的分支，它只是一个特定提交的引用。轻量标签本质上是将提交校验和存储到一个文件中，没有保存任何其他信息。创建一个轻量标签，只需要执行下面的命令。 git tag v1.8.5 而附注标签是存储在 Git 数据库中的一个完整对象。它们是可以被校验的。其中包含创建标签者的名字、电子邮件地址、日期时间，还有一个标签信息。并且可以使用 GPG 签名与验证。创建一个附注标签，只需要执行下面的命令，启动文本编辑器以便输入本次提交的说明。 git tag -a v1.8.5 另外，也可以执行下面的命令将提交信息与命令放在同一行。 git tag -a v1.8.5 -m \"COMMENT\" 你也可以对过去的提交创建标签，只需要在命令的末尾指定提交的校验和（或部分校验和）。 "},"docs/推送标签.html":{"url":"docs/推送标签.html","title":"推送标签","keywords":"","body":"推送标签 默认情况下，推送到远程仓库并不会推送标签。在创建完标签后你必须显式地推送标签到远程仓库上。如果你需要推送标签到简写为 develop 的远程仓库上，可以执行下面的命令。 git push develop v1.8.5 如果想要一次性推送很多标签到简写为 develop 的远程仓库上，可以使用 --tags 选项。这将会把所有不在远程仓库服务器上的标签全部推送到那里。 git push develop --tags "},"docs/删除标签.html":{"url":"docs/删除标签.html","title":"删除标签","keywords":"","body":"删除标签 要删除掉你本地仓库上的标签，可以执行下面的命令。 git tag -d v1.8.5 应该注意的是上述命令并不会从任何远程仓库中移除这个标签，你必须执行下面的命令来删除简写为 develop 的远程仓库中的标签。 git push develop :refs/tags/v1.8.5 "},"docs/别名.html":{"url":"docs/别名.html","title":"别名","keywords":"","body":"别名 Git 并不会在你输入部分命令时自动推断出你想要的命令。如果不想每次都输入完整的 Git 命令，可以通过执行下面的命令来轻松地为每一个命令设置一个全局别名。 git config --global alias.st status 这意味着，当要查看文件状态时，只需要执行下面的命令。 git st 随着你继续不断地使用 Git ，可能也会经常使用其它命令，所以创建别名时不要犹豫。 "},"docs/版本回退.html":{"url":"docs/版本回退.html","title":"版本回退","keywords":"","body":"版本回退 像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩 RPG 游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打 Boss 之前，你会手动存盘，以便万一打 Boss 失败了，可以从最近的地方重新开始。 Git 也是一样，每当你觉得文件修改到一定程度的时候，就可以保存一个快照。一旦你一不小心改错了文件，或者误删了文件，还可以从最近的一个快照中恢复，然后继续工作，而不是把几个月的工作成果全部丢失。如果你想把当前版本回退到上一个版本，可以执行下面的命令。 git reset --hard HEAD^ 如果你想把当前版本回退到往上三个版本，可以执行下面的命令。 git reset --hard HEAD~3 你也可以回退到提交的任何版本，只需要指定提交的校验和或部分校验和，即便它存在时空悖论。 "},"docs/存储修改.html":{"url":"docs/存储修改.html","title":"存储修改","keywords":"","body":"存储修改 有时，当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态，而这时你想要切换到另一个分支做一点别的事情。问题是，你不想仅仅因为过会儿回到这一点而为做了一半的工作创建一次提交。针对这个问题的答案是执行下面的命令，该命令会处理工作目录的脏的状态，即修改的跟踪文件与暂存改动，然后将未完成的修改保存到一个栈上，而你可以在任何时候重新应用这些改动。 git stash 在这时，你能够轻易地切换分支并在其他地方工作。你的修改被存储在栈上。要查看存储的东西，可以执行下面的命令。 git stash list 可以执行下面的命令将你刚刚存储的修改重新应用。 git stash apply 如果想要应用其中一个名为 stash@{2} 的存储，可以执行下面的命令。如果不指定一个存储， Git 会认为指定的是最近的存储。 git stash apply stash@{2} 重新应用只会尝试应用暂存的工作，在堆栈上还有它。可以执行下面的命令移除指定名为 stash@{2} 的存储。 git stash drop stash@{2} 也可以执行下面的命令来应用名为 stash@{2} 的存储然后立即从栈上移除它。 git stash pop stash@{2} "},"docs/使用镜像.html":{"url":"docs/使用镜像.html","title":"使用镜像","keywords":"","body":"使用镜像 访问 IPAddress 网站，获取以下网址的 IP 地址并添加到系统的 hosts 文件，最后刷新 DNS 缓存即可。 # GitHub IP 地址 github.com IP 地址 www.github.com IP 地址 api.github.com IP 地址 gist.github.com IP 地址 raw.github.com IP 地址 gist.github.com IP 地址 help.github.com IP 地址 codeload.github.com IP 地址 nodeload.github.com IP 地址 documentcloud.github.com IP 地址 developer.github.com IP 地址 assets-cdn.github.com IP 地址 github.global.ssl.fastly.net IP 地址 githubusercontent.com IP 地址 raw.githubusercontent.com IP 地址 camo.githubusercontent.com IP 地址 gist.githubusercontent.com IP 地址 avatars0.githubusercontent.com IP 地址 avatars1.githubusercontent.com IP 地址 avatars2.githubusercontent.com IP 地址 avatars3.githubusercontent.com IP 地址 avatars4.githubusercontent.com IP 地址 avatars5.githubusercontent.com IP 地址 avatars6.githubusercontent.com IP 地址 avatars7.githubusercontent.com IP 地址 avatars8.githubusercontent.com IP 地址 avatars9.githubusercontent.com "}}